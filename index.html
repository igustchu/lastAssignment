<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <title>final project</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>

<script>
let scene, camera, renderer, controls;
let aboutMeModel = null;
let backModel = null;
let backBackModel = null;
let creditModel = null;
let hoverObject = null;


scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
const initialCamPos = new THREE.Vector3(-5.6865, 42.4152, 417.4281);
const initialLookAt = new THREE.Vector3(0, 10, 0);
camera.position.copy(initialCamPos);
camera.lookAt(initialLookAt);

renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.shadowMap.enabled = true; // เปิด shadow map
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

const dirLight = new THREE.DirectionalLight(0xffffff, 2);
dirLight.position.set(100, 200, 100);
dirLight.castShadow = true; // ให้แสงหล่อเงา
dirLight.shadow.mapSize.width = 2048;
dirLight.shadow.mapSize.height = 2048;
dirLight.shadow.camera.near = 1;
dirLight.shadow.camera.far = 500;
dirLight.shadow.camera.left = -200;
dirLight.shadow.camera.right = 200;
dirLight.shadow.camera.top = 200;
dirLight.shadow.camera.bottom = -200;
scene.add(dirLight);

scene.add(new THREE.AmbientLight(0xffffff, 0.05));

const planeGeo = new THREE.PlaneGeometry(1000, 1000);
const planeMat = new THREE.ShadowMaterial({ opacity: 0.4 });
const plane = new THREE.Mesh(planeGeo, planeMat);
plane.rotation.x = -Math.PI/2;
plane.position.y = -100;
plane.receiveShadow = true;
scene.add(plane);


const vert = `
uniform float uTime;
varying vec3 vNormal;
varying vec2 vUv;
varying vec3 vPosW;
void main() {
  vNormal = normalize(mat3(modelMatrix) * normal);
  vUv = uv;
  vec3 pos = position;
  pos.y += sin(pos.x * 2.0 + uTime * 3.0) * 10.0;
  pos.z += cos(pos.x * 1.5 + uTime * 2.0) * 10.0;
  vPosW = (modelMatrix * vec4(pos,1.0)).xyz;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.0);
}`;
const frag = `
precision mediump float;
varying vec3 vNormal;
varying vec2 vUv;
uniform vec3 uLightDir;
uniform sampler2D uTex;
void main() {
  float diffuse = max(dot(normalize(vNormal), normalize(uLightDir)), 0.0);
  float levels = 3.0;
  diffuse = floor(diffuse * levels) / levels;
  diffuse += 0.5;
  vec3 base = texture2D(uTex, vUv).rgb;
  vec3 color = base * diffuse;
  gl_FragColor = vec4(color,1.0);
}`;

function enableShadow(model){
  model.traverse((child)=>{
    if(child.isMesh){
      child.castShadow = true;
      child.receiveShadow = true;
    }
  });
}


function loadKai(){
  const loader = new THREE.GLTFLoader();
  loader.load('model/mapraw.glb', function(gltf){
    const model = gltf.scene;
    model.scale.set(10,10,10);
    model.position.set(0,-100,0);
    model.rotation.y = -Math.PI/2;
    model.traverse((child)=>{
      if(child.isMesh){
        const tex = child.material.map || new THREE.TextureLoader().load('https://threejs.org/examples/textures/uv_grid_opengl.jpg');
        child.material = new THREE.ShaderMaterial({
          vertexShader: vert,
          fragmentShader: frag,
          uniforms: {
            uLightDir: { value: new THREE.Vector3(0.4,1,0.8).normalize() },
            uTex: { value: tex },
            uTime: { value: 0 }
          },
          side: THREE.DoubleSide
        });
      }
    });
    enableShadow(model);
    scene.add(model);
  });
}

function loadFinalMakMak(){
  const loader = new THREE.GLTFLoader();
  loader.load('model/modelss.glb', function(gltf){
    const model = gltf.scene;
    model.scale.set(10,10,10);
    model.position.set(0,-100,0);
    model.rotation.y = -Math.PI/2;
    enableShadow(model);
    scene.add(model);
  });
}

function loadCreditModel(){
  const loader = new THREE.GLTFLoader();
  loader.load('model/creditmodel.glb', function(gltf){
    const model = gltf.scene;
    model.scale.set(10,10,10);
    model.position.set(0,-100,0);
    model.rotation.y = -Math.PI/2;
    enableShadow(model);
    scene.add(model);
    creditModel = model;
  });
}

function loadSign111(){
  const loader = new THREE.GLTFLoader();
  loader.load('model/Sign111.glb', function(gltf){
    const model = gltf.scene;
    model.scale.set(10,10,10);
    model.position.set(0,-100,0);
    model.rotation.y = -Math.PI/2;
    enableShadow(model);
    scene.add(model);
  });
}

function loadAboutMe(){
  const loader = new THREE.GLTFLoader();
  loader.load('model/aboutme.glb', function(gltf){
    const model = gltf.scene;
    model.scale.set(10,10,10);
    model.position.set(0,-100,0);
    model.rotation.y = -Math.PI/2;
    enableShadow(model);
    scene.add(model);
    aboutMeModel = model;
  });
}

function loadBack(){
  const loader = new THREE.GLTFLoader();
  loader.load('model/back.glb', function(gltf){
    const model = gltf.scene;
    model.scale.set(10,10,10);
    model.position.set(0,-100,0);
    model.rotation.y = -Math.PI/2;
    enableShadow(model);
    scene.add(model);
    backModel = model;
  });
}

function loadBackBack(){
  const loader = new THREE.GLTFLoader();
  loader.load('model/backback.glb', function(gltf){
    const model = gltf.scene;
    model.scale.set(10,10,10);
    model.position.set(0,-100,0);
    model.rotation.y = -Math.PI/2;
    enableShadow(model);
    scene.add(model);
    backBackModel = model;
  }, undefined, function(err){ console.error("❌ BackBack load error:", err); });
}

// ==================
// HDRI
// ==================
const pmremGenerator = new THREE.PMREMGenerator(renderer);
pmremGenerator.compileEquirectangularShader();

const rgbeLoader = new THREE.RGBELoader();
rgbeLoader.load('hdrieiei/qwantani_sunset_puresky_1k.hdr',
  function(texture){
    const envMap = pmremGenerator.fromEquirectangular(texture).texture;
    scene.environment = envMap;
    scene.background = envMap;
    texture.dispose();
    pmremGenerator.dispose();
  },
  undefined,
  function(err){
    console.warn('⚠️ HDRI Load Error:', err);
    scene.background = new THREE.Color(0x87ceeb);
  }
);


loadKai();
loadFinalMakMak();
loadAboutMe();
loadBack();
loadBackBack();
loadSign111();
loadCreditModel();


const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const targetCamPos = new THREE.Vector3(-0.65, -2.67, 94.77);
const targetLookAt = new THREE.Vector3(11, 5, 3);

window.addEventListener('click', (event)=>{
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  if(aboutMeModel && raycaster.intersectObject(aboutMeModel,true).length>0){
    gsap.to(camera.position, { x: targetCamPos.x, y: targetCamPos.y, z: targetCamPos.z, duration:2, ease:"power2.inOut" });
    gsap.to(controls.target, { x: targetLookAt.x, y: targetLookAt.y, z: targetLookAt.z, duration:2, ease:"power2.inOut", onUpdate:()=>controls.update() });
    return;
  }

  if(backModel && raycaster.intersectObject(backModel,true).length>0){
    gsap.to(camera.position, { x: initialCamPos.x, y: initialCamPos.y, z: initialCamPos.z, duration:2, ease:"power2.inOut" });
    gsap.to(controls.target, { x: initialLookAt.x, y: initialLookAt.y, z: initialLookAt.z, duration:2, ease:"power2.inOut", onUpdate:()=>controls.update() });
    return;
  }

  if(backBackModel && raycaster.intersectObject(backBackModel,true).length>0){
    gsap.to(camera.position, { x: initialCamPos.x, y: initialCamPos.y, z: initialCamPos.z, duration:2, ease:"power2.inOut" });
    gsap.to(controls.target, { x: initialLookAt.x, y: initialLookAt.y, z: initialLookAt.z, duration:2, ease:"power2.inOut", onUpdate:()=>controls.update() });
    return;
  }

  if(creditModel && raycaster.intersectObject(creditModel,true).length>0){
    gsap.to(camera.position, { x: 1.7885, y: 7.5543, z: -45.6443, duration: 2, ease:"power2.inOut" });
    gsap.to(controls.target, { x: initialLookAt.x, y: initialLookAt.y, z: initialLookAt.z, duration:2, ease:"power2.inOut", onUpdate:()=>controls.update() });
    return;
  }
});

// ==================
// Mouse Hover
// ==================
window.addEventListener('mousemove', (event)=>{
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  let intersects = [];
  if(aboutMeModel) intersects = intersects.concat(raycaster.intersectObject(aboutMeModel,true));
  if(backModel) intersects = intersects.concat(raycaster.intersectObject(backModel,true));
  if(backBackModel) intersects = intersects.concat(raycaster.intersectObject(backBackModel,true));
  if(creditModel) intersects = intersects.concat(raycaster.intersectObject(creditModel,true));

  if(intersects.length>0){
    const object = intersects[0].object;
    if(hoverObject !== object){
      if(hoverObject) hoverObject.material.color.set(hoverObject.currentColor || 0xffffff);
      object.currentColor = object.material.color.getHex();
      object.material.color.set(0xffff00);
      hoverObject = object;
    }
  } else {
    if(hoverObject){
      hoverObject.material.color.set(hoverObject.currentColor || 0xffffff);
      hoverObject = null;
    }
  }
});


function animate(){
  requestAnimationFrame(animate);
  controls.update();

  scene.traverse((obj)=>{
    if(obj.isMesh && obj.material.uniforms && obj.material.uniforms.uTime){
      obj.material.uniforms.uTime.value = performance.now()/1000;
    }
  });

  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
